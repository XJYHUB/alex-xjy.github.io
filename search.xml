<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF1530B</title>
      <link href="/alex-xjy.github.io/2021/08/11/cf1530b/"/>
      <url>/alex-xjy.github.io/2021/08/11/cf1530b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1530/B">题目链接</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求一个h*w的01矩阵，并且使矩阵中的每两个值为$1$的点 $(x1,y1)(x2,y2)$ 满足 $|x1-x2|+|y1-y2|\gt 1$.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>本题是贪心思想，考虑枚举每一个点，如果满足要求，则赋值为1 ，否则为0.最终得到的矩阵即为所求，输出即可AC 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <bits/stdc++.h>#define ll long long#define _for(i,a,b) for(int i=(a);i<=(b);i++)namespace FastIOstream&#123;    template <typename T> inline void read(T &x)&#123;//Fast read        x=0;int f=1;char c=getchar();        for(;!isdigit(c);)&#123;if(c=='-')f=-1;c=getchar();&#125;        for(;isdigit(c);)&#123;x=(x<<1)+(x<<3)+c-48;c=getchar();&#125;        x*=f;return;    &#125;    template <typename T> void print(T x)&#123;//Fast print        if(x<0)&#123;x=-x;putchar('-');&#125;if(x>9)print((x>>1)/5);        putchar(x%10+48);return;    &#125;&#125;using namespace std;using namespace FastIOstream;int t,f[25][25],tf[25][25];bool check(int x,int y,int n,int m)&#123;    if(f[x][y]||f[x-1][y]||f[x][y-1]||f[x+1][y]||f[x][y+1]||f[x+1][y+1]||f[x-1][y-1]||f[x-1][y+1]||f[x+1][y-1])return 0;    return 1;&#125;signed main()&#123;    read(t);    for(int T=1;T<=t;T++)&#123;        memset(tf,0,sizeof(tf));        int n,m,ans=0;        read(n);        read(m);        for(int i=1;i<=n;i++)&#123;            tf[i][1]=1;            tf[i][m]=1;        &#125;        for(int j=1;j<=m;j++)&#123;            tf[1][j]=1;            tf[n][j]=1;        &#125;        int x=n>>1;        if(n&1)x++;         for(int i=1;i<=n;i++)&#123;            for(int j=1;j<=m;j++)&#123;                if(tf[i][j]&&check(i,j,n,m))&#123;                    ans++;                    f[i][j]=1;                &#125;            &#125;        &#125;        for(int i=1;i<=n;i++)&#123;            for(int j=1;j<=m;j++)&#123;                cout << f[i][j];                f[i][j]=0;            &#125;            puts(" ");        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1108C</title>
      <link href="/alex-xjy.github.io/2021/08/11/cf1108c/"/>
      <url>/alex-xjy.github.io/2021/08/11/cf1108c/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1108/C">题目链接</a></p><p>本题要我们修改最少的字符使 $s_i=s_j$ 且 $i\equiv j$  (<em>mod</em> 3).用人话来讲就是使令’R’ ‘G’ ‘B’三个字母构成的循环节构成一个字符串 $s’$。使 $\sum[{s_i\neq s’_i]}$ 最小。</p><p>由于RGB只有三个字母，构成的循环节只有6种可能，分别为RBG,RGB,GRB,GBR,BRG,BGR.我们只需枚举这六种情况组成的字符串。判断其与原始字符串不相同的个数。最后取个min即可。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <bits/stdc++.h>#define AK 1#define rep(i,a,b) for(register int i=a;i<=b;++i)#define per(i,a,b) for(register int i=a;i>=b;--i)namespace FastIOstream&#123;    template <typename T> inline void read(T &x)&#123;//Fast read        x=0;int f=1;char c=getchar();        for(;!isdigit(c);)&#123;if(c=='-')f=-1;c=getchar();&#125;        for(;isdigit(c);)&#123;x=(x<<1)+(x<<3)+c-48;c=getchar();&#125;        x*=f;return;    &#125;    template <typename T> void print(T x)&#123;//Fast print        if(x<0)&#123;x=-x;putchar('-');&#125;if(x>9)print((x>>1)/5);        putchar(x%10+48);return;    &#125;&#125;using namespace std;using namespace FastIOstream;string s[7],m;string a[7];int n,pos,num=1e9;signed main()&#123;    s[1]="RGB";s[2]="RBG";s[3]="BRG";    s[4]="BGR";s[5]="GBR";s[6]="GRB";    read(n);    cin >> m;    int k=n/3+1;    for(register int i=1;i<=6;++i)&#123;        for(register int j=1;j<=k;++j)&#123;            a[i]+=s[i];        &#125;        int sum=0;        for(register int j=0;j<n;++j)&#123;            if(m[j]!=a[i][j])sum++;        &#125;        if(sum<num)&#123;            num=sum;            pos=i;        &#125;    &#125;    print(num);    putchar('\n');    for(register int i=0;i<n;++i)&#123;        putchar(a[pos][i]);    &#125;    putchar('\n');    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1557A</title>
      <link href="/alex-xjy.github.io/2021/08/11/cf1557a/"/>
      <url>/alex-xjy.github.io/2021/08/11/cf1557a/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1557/A">题目链接</a></p><p>这是一道简单思维题，不难得出，要想使两个子序列平均值最大化，只要在原序列中取个最大值。使这个最大单独组成一个集合，剩余的数为另一个集合。在这样的分法下，两序列的平均数之和必定是最大的。下面是代码：</p><pre><code>#include &lt;bits/stdc++.h&gt;//#define int long long#define AK 1#define rep(i,a,b) for(register int i=a;i&lt;=b;++i)#define per(i,a,b) for(register int i=a;i&gt;=b;--i)namespace FastIOstream&#123;    inline void read(int &amp;x)&#123;//Fast read        x=0;int f=1;char c=getchar();        for(;!isdigit(c);)&#123;if(c==&#39;-&#39;)f=-1;c=getchar();&#125;        for(;isdigit(c);)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-48;c=getchar();&#125;        x*=f;return;    &#125;    void print(int x)&#123;//Fast print        if(x&lt;0)&#123;x=-x;putchar(&#39;-&#39;);&#125;if(x&gt;9)print((x&gt;&gt;1)/5);        putchar(x%10+48);return;    &#125;&#125;namespace Algorithm&#123;    inline int fast_power(int base,int exp)&#123;        int res=1;        for(;exp;)&#123;if(exp&amp;1)res*=base;base*=base;exp&gt;&gt;=1;&#125;        return res;    &#125;    int GCD(int x,int y)&#123;return y?x:GCD(y,x%y);&#125;&#125;using namespace std;using namespace FastIOstream;using namespace Algorithm;double a[(int)(1e6+5)];void work()&#123;    int n;    double maxn=(double)(-(1&lt;&lt;30))*1.0000000000,sum=0.00000000;    read(n);    rep(i,1,n)&#123;        scanf(&quot;%lf&quot;,&amp;a[i]);        sum+=a[i];        maxn=max(maxn,a[i]);    &#125;    printf(&quot;%.9lf\n&quot;,maxn+(sum-maxn)/(n-1));&#125;signed main()&#123;    int T;    read(T);    while(T--)&#123;        work();    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块入门</title>
      <link href="/alex-xjy.github.io/2021/08/08/fen-kuai-ru-men/"/>
      <url>/alex-xjy.github.io/2021/08/08/fen-kuai-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="分块入门"><a href="#分块入门" class="headerlink" title="分块入门"></a>分块入门</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><h3 id="1-何为分块？"><a href="#1-何为分块？" class="headerlink" title="$1.$何为分块？"></a><strong>$1.$何为分块？</strong></h3><p>所谓分块，顾名思义，就是将一个序列分成若干个块，在进行区间操作时，只需要对这个区间内所在块进行操作。因而，分块可以说就是一种支持区间操作与询问的数据结构。</p><h3 id="2-为什么要分块？"><a href="#2-为什么要分块？" class="headerlink" title="$2.$为什么要分块？"></a><strong>$2.$为什么要分块？</strong></h3><p>说到区间操作，不难想到另外两个数据结构——树状数组与线段树。事实上，在很多问题中，这三个数据结构是可以通用的。区间求和就是一个经典例子。在这个问题中，树状数组与线段树的效率比分快都要高，为什么还有很多选择分块做法呢？原因是分块是最通用，最直观的。这样说也许十分抽象，接下来本文将以区间求和这一经典例题来引入分块思想。</p><h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a><strong>声明：</strong></h2><p>不同OJ题目描述略有不同，但大多只是变量名的不同，无实质性区别。因此，请勿将同一份代码交到不同OJ。</p><h2 id="【例一】区间求和"><a href="#【例一】区间求和" class="headerlink" title="【例一】区间求和"></a><strong>【例一】区间求和</strong></h2><p><a href="https://www.luogu.com.cn/problem/P3372">题目链接</a>\<br>题目描述：给定一个长度为$n$ $(n\le 10^5)$的序列A,然后给定$q$ $(q\le 10^5)$个操作命令,操作命令如下:\<br>命令一:形如“$1$ $x$ $y$ $k$”，表示对于所有的正整数$i(x\le i\le y)$，将$A_i$加上一个$k$。\<br>命令二:形如”$2$ $x$ $y$”,表示求</p><script type="math/tex; mode=display">\sum_{i=x}^y{A_i}</script><p><a href="https://www.luogu.com.cn/problem/P3372">对于不习惯用数学符号描述最简题面的读者可以点开原题题面</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a><strong>$Solution:$</strong></h2><p>首先对数据规模进行分析，暴力肯定会超时。这可以用树状数组和线段树，但在这，我们用分块来做。\<br>分块，首先就要确定“块”的长度，方便起见,我们记$m$为块的长度。通常情况下，我们以$\lfloor \sqrt{n}\rfloor$作为块的长度，即$m=\lfloor \sqrt{n}\rfloor$。当然，大多数情况下，$n$未必是一个完全平方数，也就是说，结尾部分会有不足。这时，我们只要单独处理就可以了。因此，我们可以将序列分成如下所示(方便起见，此处$m$取$2$)：</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/02fa725b2cf21669.png" alt=""></p><p>首先，我们要确定每个块的位置。因此，我们定义$l$数组与$r$数组，作为每个块的左端点与右端点。不难得出，$l_i=(i-1)×m+1,r_i=i×m$。如果有多余的部分，则令$l_i=(i-1)×m+1,r_i=n$。\<br>$Code:$</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int num=n/m;//求出总块数for(int i=1;i<=num;++i)&#123;    l[i]=(i-1)*m+1;    r[i]=i*m;&#125;if(m*num<n)&#123;//处理多余部分    ++num;    l[i]=(num-1)*m+1;    r[i]=n;&#125;</code></pre><p>确定完每个块的边界后，我们还要判断$A_i$的所属块。经过刚才对每个块左右端点的确定，这个操作变得十分容易。我们只需要用“块”将整个数列遍历一遍即可。具体实现方式如下:\<br>$Code:$</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for(int i=1;i<=num;++i)&#123;    for(int j=l[i];j<=r[i];++j)&#123;        p[j]=i;    &#125;&#125;</code></pre><p>到此为止，分块还并未发挥它的真正作用。而接下来的，便是分块思想中最重要的一环。\<br>现在，我们要定义两个数组$sum$与$d$,分别表示每个块中数的和与每个块中的增量。首先要预处理出$sum$，这只需在刚刚的$for$循环中加一句<code>sum[i]+=a[j]</code>即可。在执行命令一时。对于一个完整的块，需要让$sum_i$加上$m*k$,并让$d_i$加上$k$。对于不完整的部分，则只要将$sum_i$加上$k$与该部分长度之积,并将原数列中对应的数加上$k$。执行命令二时，同样的，分两种情况处理。我们记该区间和为$ans$,对于不完整的部分，则暴力枚举。则让$ans$加上$A_i+d_{p_{A_i}}$,而对于一整个块，只需让$ans$加上$sum_i$即可。本来处理一个块的时间复杂度为$O(m)$，如此一来，便降到了$O(1)$。对于整个题目，暴力的时间复杂度为$O(n^2)$,而分块则像是一种“优雅的暴力”，将遍历每个数变为遍历每个块，也就是将n降低为$\sqrt{n}$,这就是分块的一个重要思想。该题分块时间复杂度理论上为$O(n)$。真实复杂度还应加上预处理与对不完整部分的处理。即便如此，$n=10^5$依然是能够支持的。</p><p><a href="https://www.luogu.com.cn/problem/P3372">$Code:$</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <bits/stdc++.h>#define AK 1#define int long longnamespace FastIOstream&#123;    template <typename T> inline void read(T &x)&#123;//Fast read    x=0;int f=1;char c=getchar();for(;!isdigit(c);)&#123;            if(c=='-')                f=-1;            c=getchar();        &#125;        for(;isdigit(c);)&#123;            x=(x<<1)+(x<<3)+c-48;            c=getchar();        &#125;        x*=f;        return;    &#125;    template <typename T>     void print(T x)&#123;//Fast print        if(x<0)&#123;            x=-x;            putchar('-');        &#125;        if(x>9)&#123;            print((x>>1)/5);        &#125;        putchar(x%10+48);        return;    &#125;&#125;using namespace std;using namespace FastIOstream;int n,t,num,k,f[100005],l[1005],r[1005],p[100005],d[1005],sum[1005];void init()&#123;    read(n);    read(t);    for(int i=1;i<=n;++i)&#123;        read(f[i]);    &#125;    k=sqrt(n);    num=n/k;    for(int i=1;i<=num;++i)&#123;        l[i]=(i-1)*k+1;        r[i]=i*k;    &#125;    if(k*num<n)&#123;        num++;        l[num]=(num-1)*k+1;        r[num]=n;    &#125;    for(int i=1;i<=num;++i)&#123;        for(int j=l[i];j<=r[i];++j)&#123;            p[j]=i;            sum[i]+=f[j];        &#125;    &#125;    return;&#125;void change(int x,int y,int w)&#123;    if(p[x]==p[y])&#123;        for(int i=x;i<=y;++i)&#123;            f[i]+=w;            sum[p[x]]+=w;        &#125;    &#125;    else&#123;        int ql=p[x]+1,qr=p[y]-1;        for(int i=ql;i<=qr;++i)&#123;            sum[i]+=w*k;            d[i]+=w;        &#125;        for(int i=x;i<=r[p[x]];++i)&#123;            sum[p[x]]+=w;            f[i]+=w;        &#125;        for(int j=l[p[y]];j<=y;++j)&#123;            sum[p[y]]+=w;            f[j]+=w;        &#125;    &#125;    return;&#125;int ask(int x,int y)&#123;    int ans=0;    if(p[x]==p[y])&#123;        for(int i=x;i<=y;++i)&#123;            ans+=f[i]+d[p[x]];        &#125;    &#125;    else&#123;        int ql=p[x]+1,qr=p[y]-1;        for(int i=ql;i<=qr;++i)&#123;            ans+=sum[i];        &#125;        for(int i=x;i<=r[p[x]];++i)&#123;            ans+=f[i]+d[p[x]];        &#125;        for(int j=l[p[y]];j<=y;++j)&#123;             ans+=f[j]+d[p[y]];        &#125;    &#125;    return ans;&#125;signed main()&#123;    init();    for(int i=1;i<=t;++i)&#123;        int op,x,y,w;        read(op);        read(x);        read(y);        if(op==1)&#123;            read(w);            change(x,y,w);        &#125;        else&#123;            print(ask(x,y));            puts(" ");        &#125;    &#125;    return 0;&#125;</code></pre><p>$Markdown$<br>$with$<br>$\LaTeX$<br>TAG</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
