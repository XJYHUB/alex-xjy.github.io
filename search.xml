<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Euler函数初步</title>
      <link href="/alex-xjy.github.io/2021/08/11/euler-han-shu-chu-bu/"/>
      <url>/alex-xjy.github.io/2021/08/11/euler-han-shu-chu-bu/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>接触了数论之后，发现很多东西即使理解了，也很难去记住。很多东西看似理解了，在做题过程中很多东西也未深入理解。因此，写了这篇博客。由于是第一次这种数学博客，有不足之处，还指出。另外，由于本人水平有限，一些定理可能无法给出证明，为了保证文章的完整性，我会引用别处的证明，并标注来源，读者可自行选择查看。</p><h1 id="正文">正文</h1><h2 id="定义">定义</h2><blockquote><p>对于正整数 <span class="math inline">\(n\)</span>,欧拉函数 <span class="math inline">\(\varphi(n)\)</span> 是小于 <span class="math inline">\(n\)</span> 的正整数中与 <span class="math inline">\(n\)</span> 互质的数的数目。此函数以其首名研究者欧拉命名，它又称为 <span class="math inline">\(\phi\)</span> 函数(由高斯所命名)或是欧拉总计函数( <span class="math inline">\(totient\)</span> <span class="math inline">\(function\)</span> ，由西尔维斯特所命名)。</p></blockquote><p>举个<del>栗子</del>: 因为有 <span class="math inline">\(1,3,5,6\)</span> 与 <span class="math inline">\(8\)</span> 互质，所以 <span class="math inline">\(\varphi(8)=4\)</span></p><blockquote><p>以上来自 <span class="math inline">\(Wikipedia\)</span></p></blockquote><h2 id="算术基本定理及其推论">算术基本定理及其推论</h2><p>会算约数个数及约数和可跳过</p><p>算术基本定理就是在告诉我们，对于任何一个正整数 <span class="math inline">\(n\)</span> ,都可一被唯一写成 <span class="math inline">\(p_1^{k_1}p_2^{k_2}p_3^{k_3}\dots p_m^{k_m}\)</span> 的形式。 对于每一个 <span class="math inline">\(p^{k}\)</span> 质因子，都有 <span class="math inline">\(k+1\)</span> 个约数，因此，根据乘法原理，我们可以的出正整数的正约数计算公式： <span class="math display">\[(k_1+1)\times(k_2+1)\times(k_3+1)\times \dots \times(k_m+1)=\prod_{i=1}^{m}{k_i+1}\]</span></p><p>由此又推导出正约数和的计算公式：</p><p><span class="math display">\[\prod_{i=1}^{m}{\left(\sum_{j=0}^{k_i}{(p_i)^j}\right)}\]</span></p><h2 id="欧拉函数计算方法">欧拉函数计算方法</h2><p>根据算术基本定理，我们可以推出 <span class="math inline">\(\varphi(n)\)</span> 的计算方法。首先，我们将 <span class="math inline">\(n\)</span> 分解为 <span class="math inline">\(p_1^{k_1}p_2^{k_2}p_3^{k_3}\dots p_m^{k_m}\)</span> 的形式，其中 <span class="math inline">\(p\)</span> 为质数。给出公式：</p><p><span class="math display">\[\varphi(n)=n\times \prod_{p|n}{\left(1-\frac{1}{p}\right)}\]</span></p><h3 id="证明">证明：</h3><p>先考虑只有两个质因子的情况。我们记这两个质因子为 <span class="math inline">\(p\)</span> <span class="math inline">\(q\)</span> ,这时我们只需用 <span class="math inline">\(n\)</span> 减去 <span class="math inline">\(p\)</span> <span class="math inline">\(q\)</span> ,的倍数即可。在 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(n\)</span> 中， <span class="math inline">\(p\)</span> <span class="math inline">\(q\)</span> ,的倍数个数分别为 <span class="math inline">\(\frac{n}{p}\)</span> 和 <span class="math inline">\(\frac{n}{q}\)</span> 。但是 <span class="math inline">\(p\)</span> <span class="math inline">\(q\)</span> ,的倍数中会有重复，因此，我们还应将重复的部分加回来。而重复的部分便是 <span class="math inline">\(pq\)</span> ,的倍数，个数为 <span class="math inline">\(\frac{n}{pq}\)</span>。最终得出，</p><p><span class="math display">\[\varphi(n)=n-\frac{n}{p}-\frac{n}{q}+\frac{n}{pq}=n\times\left(1-\frac{1}{p}-\frac{1}{q}+\frac{1}{pq}\right)=n\times\left(1-\frac{1}{p}\right)\left(1-\frac{1}{q}\right)\]</span></p><p>同样的我们对所有质因子进行这样的操作，就得到我们结果了。</p><hr /><p>暂未完成</p>]]></content>
      
      
      <categories>
          
          <category> 数学知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1530B</title>
      <link href="/alex-xjy.github.io/2021/08/11/cf1530b/"/>
      <url>/alex-xjy.github.io/2021/08/11/cf1530b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1530/B">题目链接</a></p><h4 id="题目大意">题目大意：</h4><p>求一个h*w的01矩阵，并且使矩阵中的每两个值为<span class="math inline">\(1\)</span>的点 <span class="math inline">\((x1,y1)(x2,y2)\)</span> 满足 <span class="math inline">\(|x1-x2|+|y1-y2|\gt 1\)</span>.</p><h3 id="solution">Solution:</h3><p>本题是贪心思想，考虑枚举每一个点，如果满足要求，则赋值为1 ，否则为0.最终得到的矩阵即为所求，输出即可AC 。</p><h3 id="code">Code:</h3><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#define _for</span>(i,a,b)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=(a);i&lt;=(b);i++)</a><a class="sourceLine" id="cb1-4" title="4"> </a><a class="sourceLine" id="cb1-5" title="5"><span class="kw">namespace</span> FastIOstream&#123;</a><a class="sourceLine" id="cb1-6" title="6">    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">inline</span> <span class="dt">void</span> read(T &amp;x)&#123;<span class="co">//Fast read</span></a><a class="sourceLine" id="cb1-7" title="7">        x=<span class="dv">0</span>;<span class="dt">int</span> f=<span class="dv">1</span>;<span class="dt">char</span> c=getchar();</a><a class="sourceLine" id="cb1-8" title="8">        <span class="cf">for</span>(;!isdigit(c);)&#123;<span class="cf">if</span>(c==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>;c=getchar();&#125;</a><a class="sourceLine" id="cb1-9" title="9">        <span class="cf">for</span>(;isdigit(c);)&#123;x=(x&lt;&lt;<span class="dv">1</span>)+(x&lt;&lt;<span class="dv">3</span>)+c-<span class="dv">48</span>;c=getchar();&#125;</a><a class="sourceLine" id="cb1-10" title="10">        x*=f;<span class="cf">return</span>;</a><a class="sourceLine" id="cb1-11" title="11">    &#125;</a><a class="sourceLine" id="cb1-12" title="12">    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> print(T x)&#123;<span class="co">//Fast print</span></a><a class="sourceLine" id="cb1-13" title="13">        <span class="cf">if</span>(x&lt;<span class="dv">0</span>)&#123;x=-x;putchar(<span class="ch">&#39;-&#39;</span>);&#125;<span class="cf">if</span>(x&gt;<span class="dv">9</span>)print((x&gt;&gt;<span class="dv">1</span>)/<span class="dv">5</span>);</a><a class="sourceLine" id="cb1-14" title="14">        putchar(x%<span class="dv">10</span>+<span class="dv">48</span>);<span class="cf">return</span>;</a><a class="sourceLine" id="cb1-15" title="15">    &#125;</a><a class="sourceLine" id="cb1-16" title="16">&#125;</a><a class="sourceLine" id="cb1-17" title="17">     </a><a class="sourceLine" id="cb1-18" title="18"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-19" title="19"><span class="kw">using</span> <span class="kw">namespace</span> FastIOstream;</a><a class="sourceLine" id="cb1-20" title="20"> </a><a class="sourceLine" id="cb1-21" title="21"><span class="dt">int</span> t,f[<span class="dv">25</span>][<span class="dv">25</span>],tf[<span class="dv">25</span>][<span class="dv">25</span>];</a><a class="sourceLine" id="cb1-22" title="22"> </a><a class="sourceLine" id="cb1-23" title="23"><span class="dt">bool</span> check(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> n,<span class="dt">int</span> m)&#123;</a><a class="sourceLine" id="cb1-24" title="24">    <span class="cf">if</span>(f[x][y]||f[x-<span class="dv">1</span>][y]||f[x][y-<span class="dv">1</span>]||f[x+<span class="dv">1</span>][y]||f[x][y+<span class="dv">1</span>]||f[x+<span class="dv">1</span>][y+<span class="dv">1</span>]||f[x-<span class="dv">1</span>][y-<span class="dv">1</span>]||f[x-<span class="dv">1</span>][y+<span class="dv">1</span>]||f[x+<span class="dv">1</span>][y-<span class="dv">1</span>])<span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-25" title="25">    <span class="cf">return</span> <span class="dv">1</span>;</a><a class="sourceLine" id="cb1-26" title="26">&#125;</a><a class="sourceLine" id="cb1-27" title="27">     </a><a class="sourceLine" id="cb1-28" title="28"><span class="dt">signed</span> main()&#123;</a><a class="sourceLine" id="cb1-29" title="29">    read(t);</a><a class="sourceLine" id="cb1-30" title="30">    <span class="cf">for</span>(<span class="dt">int</span> T=<span class="dv">1</span>;T&lt;=t;T++)&#123;</a><a class="sourceLine" id="cb1-31" title="31">        memset(tf,<span class="dv">0</span>,<span class="kw">sizeof</span>(tf));</a><a class="sourceLine" id="cb1-32" title="32">        <span class="dt">int</span> n,m,ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-33" title="33">        read(n);</a><a class="sourceLine" id="cb1-34" title="34">        read(m);</a><a class="sourceLine" id="cb1-35" title="35">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)&#123;</a><a class="sourceLine" id="cb1-36" title="36">            tf[i][<span class="dv">1</span>]=<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-37" title="37">            tf[i][m]=<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-38" title="38">        &#125;</a><a class="sourceLine" id="cb1-39" title="39">        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=m;j++)&#123;</a><a class="sourceLine" id="cb1-40" title="40">            tf[<span class="dv">1</span>][j]=<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-41" title="41">            tf[n][j]=<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-42" title="42">        &#125;</a><a class="sourceLine" id="cb1-43" title="43">        <span class="dt">int</span> x=n&gt;&gt;<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-44" title="44">        <span class="cf">if</span>(n&amp;<span class="dv">1</span>)x++; </a><a class="sourceLine" id="cb1-45" title="45">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)&#123;</a><a class="sourceLine" id="cb1-46" title="46">            <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=m;j++)&#123;</a><a class="sourceLine" id="cb1-47" title="47">                <span class="cf">if</span>(tf[i][j]&amp;&amp;check(i,j,n,m))&#123;</a><a class="sourceLine" id="cb1-48" title="48">                    ans++;</a><a class="sourceLine" id="cb1-49" title="49">                    f[i][j]=<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-50" title="50">                &#125;</a><a class="sourceLine" id="cb1-51" title="51">            &#125;</a><a class="sourceLine" id="cb1-52" title="52">        &#125;</a><a class="sourceLine" id="cb1-53" title="53">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)&#123;</a><a class="sourceLine" id="cb1-54" title="54">            <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=m;j++)&#123;</a><a class="sourceLine" id="cb1-55" title="55">                cout &lt;&lt; f[i][j];</a><a class="sourceLine" id="cb1-56" title="56">                f[i][j]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-57" title="57">            &#125;</a><a class="sourceLine" id="cb1-58" title="58">            puts(<span class="st">&quot; &quot;</span>);</a><a class="sourceLine" id="cb1-59" title="59">        &#125;</a><a class="sourceLine" id="cb1-60" title="60">    &#125;</a><a class="sourceLine" id="cb1-61" title="61">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-62" title="62">&#125;</a></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1108C</title>
      <link href="/alex-xjy.github.io/2021/08/11/cf1108c/"/>
      <url>/alex-xjy.github.io/2021/08/11/cf1108c/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1108/C">题目链接</a></p><p>本题要我们修改最少的字符使 <span class="math inline">\(s_i=s_j\)</span> 且 <span class="math inline">\(i\equiv j\)</span> (<em>mod</em> 3).用人话来讲就是使令'R' 'G' 'B'三个字母构成的循环节构成一个字符串 <span class="math inline">\(s&#39;\)</span>。使 <span class="math inline">\(\sum[{s_i\neq s&#39;_i]}\)</span> 最小。</p><p>由于RGB只有三个字母，构成的循环节只有6种可能，分别为RBG,RGB,GRB,GBR,BRG,BGR.我们只需枚举这六种情况组成的字符串。判断其与原始字符串不相同的个数。最后取个min即可。</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#define AK </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#define rep</span>(i,a,b)<span class="pp"> </span><span class="cf">for</span>(<span class="at">register</span><span class="pp"> </span><span class="dt">int</span><span class="pp"> </span>i=a;i&lt;=b;++i)</a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#define per</span>(i,a,b)<span class="pp"> </span><span class="cf">for</span>(<span class="at">register</span><span class="pp"> </span><span class="dt">int</span><span class="pp"> </span>i=a;i&gt;=b;--i)</a><a class="sourceLine" id="cb1-5" title="5"></a><a class="sourceLine" id="cb1-6" title="6"><span class="kw">namespace</span> FastIOstream&#123;</a><a class="sourceLine" id="cb1-7" title="7">    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">inline</span> <span class="dt">void</span> read(T &amp;x)&#123;<span class="co">//Fast read</span></a><a class="sourceLine" id="cb1-8" title="8">        x=<span class="dv">0</span>;<span class="dt">int</span> f=<span class="dv">1</span>;<span class="dt">char</span> c=getchar();</a><a class="sourceLine" id="cb1-9" title="9">        <span class="cf">for</span>(;!isdigit(c);)&#123;<span class="cf">if</span>(c==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>;c=getchar();&#125;</a><a class="sourceLine" id="cb1-10" title="10">        <span class="cf">for</span>(;isdigit(c);)&#123;x=(x&lt;&lt;<span class="dv">1</span>)+(x&lt;&lt;<span class="dv">3</span>)+c-<span class="dv">48</span>;c=getchar();&#125;</a><a class="sourceLine" id="cb1-11" title="11">        x*=f;<span class="cf">return</span>;</a><a class="sourceLine" id="cb1-12" title="12">    &#125;</a><a class="sourceLine" id="cb1-13" title="13">    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> print(T x)&#123;<span class="co">//Fast print</span></a><a class="sourceLine" id="cb1-14" title="14">        <span class="cf">if</span>(x&lt;<span class="dv">0</span>)&#123;x=-x;putchar(<span class="ch">&#39;-&#39;</span>);&#125;<span class="cf">if</span>(x&gt;<span class="dv">9</span>)print((x&gt;&gt;<span class="dv">1</span>)/<span class="dv">5</span>);</a><a class="sourceLine" id="cb1-15" title="15">        putchar(x%<span class="dv">10</span>+<span class="dv">48</span>);<span class="cf">return</span>;</a><a class="sourceLine" id="cb1-16" title="16">    &#125;</a><a class="sourceLine" id="cb1-17" title="17">&#125;</a><a class="sourceLine" id="cb1-18" title="18"></a><a class="sourceLine" id="cb1-19" title="19"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> FastIOstream;</a><a class="sourceLine" id="cb1-21" title="21"></a><a class="sourceLine" id="cb1-22" title="22">string s[<span class="dv">7</span>],m;</a><a class="sourceLine" id="cb1-23" title="23">string a[<span class="dv">7</span>];</a><a class="sourceLine" id="cb1-24" title="24"><span class="dt">int</span> n,pos,num=<span class="fl">1e9</span>;</a><a class="sourceLine" id="cb1-25" title="25"></a><a class="sourceLine" id="cb1-26" title="26"><span class="dt">signed</span> main()&#123;</a><a class="sourceLine" id="cb1-27" title="27">    s[<span class="dv">1</span>]=<span class="st">&quot;RGB&quot;</span>;s[<span class="dv">2</span>]=<span class="st">&quot;RBG&quot;</span>;s[<span class="dv">3</span>]=<span class="st">&quot;BRG&quot;</span>;</a><a class="sourceLine" id="cb1-28" title="28">    s[<span class="dv">4</span>]=<span class="st">&quot;BGR&quot;</span>;s[<span class="dv">5</span>]=<span class="st">&quot;GBR&quot;</span>;s[<span class="dv">6</span>]=<span class="st">&quot;GRB&quot;</span>;</a><a class="sourceLine" id="cb1-29" title="29">    read(n);</a><a class="sourceLine" id="cb1-30" title="30">    cin &gt;&gt; m;</a><a class="sourceLine" id="cb1-31" title="31">    <span class="dt">int</span> k=n/<span class="dv">3</span>+<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-32" title="32">    <span class="cf">for</span>(<span class="at">register</span> <span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=<span class="dv">6</span>;++i)&#123;</a><a class="sourceLine" id="cb1-33" title="33">        <span class="cf">for</span>(<span class="at">register</span> <span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=k;++j)&#123;</a><a class="sourceLine" id="cb1-34" title="34">            a[i]+=s[i];</a><a class="sourceLine" id="cb1-35" title="35">        &#125;</a><a class="sourceLine" id="cb1-36" title="36">        <span class="dt">int</span> sum=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-37" title="37">        <span class="cf">for</span>(<span class="at">register</span> <span class="dt">int</span> j=<span class="dv">0</span>;j&lt;n;++j)&#123;</a><a class="sourceLine" id="cb1-38" title="38">            <span class="cf">if</span>(m[j]!=a[i][j])sum++;</a><a class="sourceLine" id="cb1-39" title="39">        &#125;</a><a class="sourceLine" id="cb1-40" title="40">        <span class="cf">if</span>(sum&lt;num)&#123;</a><a class="sourceLine" id="cb1-41" title="41">            num=sum;</a><a class="sourceLine" id="cb1-42" title="42">            pos=i;</a><a class="sourceLine" id="cb1-43" title="43">        &#125;</a><a class="sourceLine" id="cb1-44" title="44">    &#125;</a><a class="sourceLine" id="cb1-45" title="45">    print(num);</a><a class="sourceLine" id="cb1-46" title="46">    putchar(<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>);</a><a class="sourceLine" id="cb1-47" title="47">    <span class="cf">for</span>(<span class="at">register</span> <span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;++i)&#123;</a><a class="sourceLine" id="cb1-48" title="48">        putchar(a[pos][i]);</a><a class="sourceLine" id="cb1-49" title="49">    &#125;</a><a class="sourceLine" id="cb1-50" title="50">    putchar(<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>);</a><a class="sourceLine" id="cb1-51" title="51">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-52" title="52">&#125;</a></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学隙杂笔</title>
      <link href="/alex-xjy.github.io/2021/08/11/xue-xi-za-bi/"/>
      <url>/alex-xjy.github.io/2021/08/11/xue-xi-za-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本站本来应该是一个学术博客，但本人偏又爱好文学，闲暇之时，经常会去作些文章。又生性懒惰，不想再搭建一个博客，只好将本站亦作为本人的生活文学。但又不想占用太多空间，因此本人所有作品都在此。也算是给科学添几分书香气罢。</p><p>见笑了。</p><h1 id="诗词">诗词</h1><h2 id="水调歌头">水调歌头</h2><p>清明伤节至,</p><p>百姓皆心伤。</p><p>勾起红尘旧事,</p><p>记那番怅惘。</p><p>柱杖踏前不忍,</p><p>却恐错魂归兮。</p><p>鞭马倚车去。</p><p>年岁将遒尽,</p><p>仰明月太息。</p><p>风飒飒,</p><p>木萧萧,</p><p>雨溟溟。</p><p>一泓春水,</p><p>惹得行人苦思量。</p><p>竹树交通纵横,</p><p>乱坟匿于山岗。</p><p>料峭春风起,</p><p>枝摇花自怜,</p><p>更添几分愁。</p><h2 id="过胡头家村">过胡头家村</h2><p>雾蒙绕青山，</p><p>兰芷花满天。</p><p>驾车归故里，</p><p>阡陌漫紫烟。</p><p><span class="math inline">\(2021/5/19\)</span></p><h1 id="文章">文章</h1><h2 id="微观世界">微观世界</h2><p>记得之前看到过一篇文章,上面讲,语文和历史在本质上是一样的,都是研 究人与环境之间关系的学科。当时我奉其为真理。后来,这个“真理”动摇了。 我想究其原因,却不知从何下手。一次,也许是妙手偶得,答案悄然粗钻进了我 的脑中。语文——不如说是文学,正是宏观历史中的微观世界。</p><p>说实话,每当在读历史时,总会有种少了些什么的感觉。而这缺失的部分, 总能于文学作品中得到弥补。比如说,历史书上,对安史之乱的描述可能仅有一 句“给人民带来了深重的灾难。”。而在文学作品中,通过“惟有乳下孙”的老妪, “十指黑”的卖炭翁,却得以真切感受到战争时,人民之困苦,社会的混乱。 可毕竟,语文历史只不过是两门客观上的学科。在对这两门学科的剖析中, 我明白了一些其他东西。</p><p>这次疫情,在每个人都烙下了深刻的印记,惯于和平的人们从此次“战争” 中得到了思想的升华。疫情期间,学校组织了一次作文征集活动。我也参与其中, 并登上校刊。作为回报,我拿到了一本。上面收录着从初一到高三优秀的学生作 品。回家后,我看了几篇其中的作品。无外乎,都是在赞美白衣天使,钟南山或 是李兰娟。这倒也没错,只是有些千篇一律了——虽我也如此。但过了几个月后, 我的意见却变化了。至于为何,先从一部电影说起。</p><p>一直以来,中国的科幻电影事业总是不被看好,事实也的确如此。直到一九 年时,《流浪地球》的横空出世打破了这一局面,票房大卖。为什么这部电影能够 取得如此成就?在大多数人看来,这是因其震撼的视效,强大的音响。可在我看来,却不尽然。 在外国,视效大片比比皆是,可评分高的能有几个呢?我想,《流浪地球》的 成功还在于中国人特有的,对故乡的情思,微渺者的刻画。国外,不论是漫威还 是 DC,以及其他的一些科幻作品,都有着极强的英雄主义。套路无非就是地球有 难,拥有超能力的人来拯救地球。而《流浪地球》中,主角不过是一介平民,而 最后拯救世界的,不是一个人,而是全人类。电影中所刻画的,没有超级英雄, 高级将领,而是灾难中的微观世界。</p><p>回到这次疫情中的作文,之所以不甚满意,就是因为大家都只看到了电视中 的英雄人物,而忽略了,也忘记了,疫情下的微观世界。那期间的微观世界,或 是你与家长之间的争吵,新冠带来的焦虑,抑或是门口志愿者之间的寒暄,送菜 人到你家门前,你口中的一句谢谢。对于我们来说,这才是更有意义,更有价值 的。</p><p>放下手机,仰望前方,与邻居们一起唠嗑,与家人们欢聚一堂。一起踏雪寻 梅,闻花香,与君共赏,这微观世界。</p><h2 id="under-the-moon">Under the moon</h2><p>月,似乎与中国人中有着一种特别的情思。历来文人的文章中,月似乎是不可少的。 于今,月已然演变成一种代表思乡的意象。我在月光中长大,仔细想罢,我与月也是不可 分的。忽有感,写下此文来记忆其月下的自己。</p><p>幼时,也就是上小学时,尚无晚自习,但白天究竟还是要上课的。于是乎,我只有在 晚上才有机会与伙伴们在一起耍玩。那时,球场是我们游戏的主要场地。虽是球场,倒也 没几人打球,只有一群孩子罢。一些无人没做过的游戏,像捉人,丢沙包,自然是玩过的。 但富有创造力的孩子们也自然不会满足。于是我们便“发明”出来了一些游戏。说来也巧,虽 是我们自己想出来的游戏,长大后与人说起,别人却也玩过,只是叫法不一。这也许就是 许多人的童年如此相似的原因吧。</p><p>因为是晚上,外头很黑。但好在球场有照明灯。灯一打开,广场舞大妈们便会携着音 响,如期而至。而这时,早就在此玩的我们就只得让步了。好在旁边还有一块空场,以供 游玩。冬天,天黑得早,早就来到球场的我们,正准备玩“磕牌”的游戏。也就是大家小时 都玩过的胶牌或纸牌。此时,无光可谓煞景之事。但没有解决不了的问题。其中一个人, 用棍子将电闸门撬了开,随即打开电闸,灯便亮了起来。想必,是因为管理员没想到,有 人会想到自己开灯,所以锁紧。也许,是无人会想到这点——除了孩子。童年总是一个人“脑 洞”最大的时候,不是吗?</p><p>打开灯,我们又能继续玩了。可当广场舞大妈跳完舞,背着音响,回了家,同时也带 走了灯光。那时,还没人去开灯的电闸。生物是能适应环境的。于是,我们发明出了无需 光游戏。其中,令我印象最深的,就属捉迷藏了。在亮光中,玩捉迷藏总不是很尽兴,在 灯熄之后,只剩月光,倒能如愿以偿了。孩子是天生的躲藏高手——他们总能躲在一个你 意想不到的地方。有时,我们找不到,躲起来的人也不出来。到了晚点,我们得回去了, 他却还在那躲着。家长来了,他才会悄声无息的绕道家长身后,叫道: “我在这! ”,接着便是 一顿竹笋炒肉了。 玩完后总是要归家的。与伙伴一起时,天不怕,地不怕,天王老子都敢骂。可自己独 自回家,只有几束微弱的月光可以为你引路时,又是另一番境况了。</p><p>晚上回去时,一般都是九点左右。到那时候,球场的照明灯早就熄了,回去路上,只 有几盏路灯,散发着昏黄而又微弱的光芒。星空中,只有嫦娥与北极星相伴,洒下皎皎月 光。然而,作为一个孩子,暂时还体会不到“暂伴月将影”的兴致。只有一个八九岁的孩童 对漆黑世界的恐惧。</p><p>从球场回家,要经过一条约莫两百米的小路。白月光与淡黄的灯光交织在小路上。在 我走回家时,偶然碰到一个人,黑暗中却看不见他的脸,这让我想起了老故事中来寻仇的 厉鬼。说来也怪,我并不信鬼,却会怕鬼,到现在我仍旧没弄清为什么。每每遇到这种情 形,我会加快脚步,心跳也不由得加快了,直至走到自家楼梯口前,才放慢了脚步。 那会我还没住入电梯房,灯也还是声控的。我家在五楼,走进楼道中,只见漆黑一片。 我大声叫去,整栋楼的灯都亮了起来了。余音在我的耳畔回荡着。随后,我会立即以最快 的速度奔上五楼,每至那时,总感觉有人在追我。一会儿,我便我踏至家门口,从口袋掏 出钥匙,插进钥匙孔,悚然回头一望,想看看是否真的有人在追我,与此同时,迅速转动 钥匙,握住门把手,把门打开。有时候,锁眼因许久没上油,拧不动,就只得敲门,让爸 妈来开了。等待期间,我总是会四处张望,生怕我想象中追我的那个人,会从什么地方窜 出。进入家门后,加快的心跳才逐渐平缓下来。第二天,一觉醒来,昨晚的的经历又会如 梦境一般,被藏入童年记忆深处的某个角落中,数千次这样的经历堆积起来,愈加深刻。 时至今日,这段现今想来啼笑皆非的记忆才被我打捞出,放进硬盘里,成为我一生的永不 忘的记忆。不说小时候,就是现在,我也是极讨厌坐小汽车的——只因车中皮制座椅的味道。因 此,当我坐车时,我只好打开窗,趴在上面,大口吸进窗外充满着大自然的空气。当长途 坐在车上时,总不免无聊,只能盯着天空。晚上时,便有月陪伴我了。望着月,总不免沉 思。有那么一些时候,我似乎是能和古时诗人产生一些共鸣了。那种“暂伴月将影”的感觉像 是涌上了我的脑海。小时候不懂月,只知“呼作白玉盘”,但我却觉着月倒像个大白石,悬挂 于空中。那会儿,还不知地理,不知何为“昼半球”“夜半球”,认为此时全世界都是漆黑一片, 月光则是洒在了黑暗中的每个罅隙中,心中不免生出几分敬畏之心。可当月缺失,又生得 几分可爱,亲切许多了。</p><p>白天时,月落日升,百无聊赖的我就只好望着苍蓝的天空。细细观察,却发现白天也 是有月的。一轮象牙般的洁白之月悬在天空中,只不过她的辉光,已被强烈的日照遮住, 因此她本月也不是很明显了。可即便如此,也有日月同辉之时,太阳神也,有时也不得不 让步嫦娥了。月就如一名腼腆而又热心的女子,只有当太阳歇息时,她才敢出来点亮世界, 而偶然鼓起勇气的她,也会出来与太阳争位。</p><p>观月中,我思考了很多东西,一时是记不起了。而自搬家后,我观月的情思又发生转 变了,这也许会成为我人生的转折。</p><p>初中时,父母为了让我能有更好的学习环境,便搬到“市”里来了。自从到了九江,儿 时的伙伴也再也没联系过了。几年前,月下的无忧记忆再也没有了。小时候,虽那些欢乐 时光大多是在月下,却对月无所感触。现在望月时,时常会勾起儿时的记忆。几分淡淡的 怅惘总会浮于脑中,总感觉十分遗憾。人真是矛盾的动物,小时候盼望快点长大,长大后 却又嫌童年流逝太快。好在不只有我,还有月亮见证了我的童年。这使得我看月时,仍是 能找到儿时的感觉的。只是那种欢乐,那种无忧无虑,那种单纯之心,是再也找不回来了。 步入中学,因为学业,晚上玩耍成了上晚自习,再也不能出去玩了。但只是出去恐怕 也没人了。在班上,我最喜欢的位置莫过于第四组了。每当轮到我坐到第四组时,我总有 种归属感。在这儿,旁边开着窗子,透过窗,可见一轮明月挂天上。幸运的人用童年弥补 一生,不幸之人用一生弥补童年。我想我便是前者吧,每当前路迷茫,想去放弃时,望望 天上的月,望望心中的月,一种来自童年的,来自人类最原始的不知名的力量,总会鼓舞 着我,让我前行。</p><p>昨天晚上,我做了个梦,梦的内容呢,不过是在童年时极其普通的一次玩耍罢。醒来 之后,也不过是有些遗憾,不过是有些惋惜,不过是又点想哭,不过是意识到这又是生活 的一个新起点吧。</p><p><span class="math inline">\(2021/5/2\)</span> 起笔</p><p><span class="math inline">\(2021/5/7\)</span> 完成</p><h1 id="译作">译作</h1><h2 id="离骚">离骚</h2><p>我，不仅是伯庸之子，还是颛顼帝的后人。 那年正月， 岁星运行此时，刚好是庚寅时候， 我降临到了这个世界。 我的父亲呢，见我的生辰， 便给我取了个吉祥的名字——名正则，字灵均。</p><p>不只是上天赐予我内心的美好， 我自己亦在培育自己的修养。 江离芷草被我披挂于身， 并将秋兰作为佩饰，系在腰间。</p><p>时光飞逝啊，我仿佛已追不上， 唯恐岁月不等人。 晨兮，前往阰山拔木兰草， 黄昏，在小洲采摘宿莽。</p><p>日月交替，时光速逝， 春秋轮变，习以为常。 只是怕草木飘零， 美人逐渐老去啊！ 为什么不趁年少力壮， 去改掉这些法度？ 踏上骐骥马驰骋， 来，我为你们引路！</p><p>当年三君品德至善， 所以众贤臣拥护他们。 就如申椒与菌桂交合， 岂止是佩带蕙茝？</p><p>尧舜的光明磊落， 让他得道前行。 桀纣的猖獗， 让他们歪走邪道，寸步难行。 今时奸人的苟且享乐， 让前方道路狭隘又黑暗。 岂是我害怕灾祸？ 我只是为皇室的败落而担心啊！</p><p>我匆忙奔走， 为追随国君。 只可惜那荃草不察吾心， 信谗言而暴怒与我。</p><p>我当然知道直言贤语会为自己招来忧患， 想离开却于心不忍。 苍天为证， 这样只是为楚王啊！ 已期约黄昏相遇， 不料他中途竟改道！ 开始明明说好， 但他却几番后悔逃遁。</p><p>我本不想与其离别， 只是他数次变化已伤我心。 --------------- 暂未完成</p><h1 id="日记">日记</h1>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1557A</title>
      <link href="/alex-xjy.github.io/2021/08/11/cf1557a/"/>
      <url>/alex-xjy.github.io/2021/08/11/cf1557a/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1557/A">题目链接</a></p><p>这是一道简单思维题，不难得出，要想使两个子序列平均值最大化，只要在原序列中取个最大值。使这个最大单独组成一个集合，剩余的数为另一个集合。在这样的分法下，两序列的平均数之和必定是最大的。下面是代码：</p><pre><code>#include &lt;bits/stdc++.h&gt;//#define int long long#define AK 1#define rep(i,a,b) for(register int i=a;i&lt;=b;++i)#define per(i,a,b) for(register int i=a;i&gt;=b;--i)namespace FastIOstream&#123;    inline void read(int &amp;x)&#123;//Fast read        x=0;int f=1;char c=getchar();        for(;!isdigit(c);)&#123;if(c==&#39;-&#39;)f=-1;c=getchar();&#125;        for(;isdigit(c);)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-48;c=getchar();&#125;        x*=f;return;    &#125;    void print(int x)&#123;//Fast print        if(x&lt;0)&#123;x=-x;putchar(&#39;-&#39;);&#125;if(x&gt;9)print((x&gt;&gt;1)/5);        putchar(x%10+48);return;    &#125;&#125;namespace Algorithm&#123;    inline int fast_power(int base,int exp)&#123;        int res=1;        for(;exp;)&#123;if(exp&amp;1)res*=base;base*=base;exp&gt;&gt;=1;&#125;        return res;    &#125;    int GCD(int x,int y)&#123;return y?x:GCD(y,x%y);&#125;&#125;using namespace std;using namespace FastIOstream;using namespace Algorithm;double a[(int)(1e6+5)];void work()&#123;    int n;    double maxn=(double)(-(1&lt;&lt;30))*1.0000000000,sum=0.00000000;    read(n);    rep(i,1,n)&#123;        scanf(&quot;%lf&quot;,&amp;a[i]);        sum+=a[i];        maxn=max(maxn,a[i]);    &#125;    printf(&quot;%.9lf\n&quot;,maxn+(sum-maxn)/(n-1));&#125;signed main()&#123;    int T;    read(T);    while(T--)&#123;        work();    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块入门</title>
      <link href="/alex-xjy.github.io/2021/08/08/fen-kuai-ru-men/"/>
      <url>/alex-xjy.github.io/2021/08/08/fen-kuai-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="分块入门">分块入门</h1><h2 id="引言"><strong>引言</strong></h2><h3 id="何为分块"><strong><span class="math inline">\(1.\)</span>何为分块？</strong></h3><p>所谓分块，顾名思义，就是将一个序列分成若干个块，在进行区间操作时，只需要对这个区间内所在块进行操作。因而，分块可以说就是一种支持区间操作与询问的数据结构。</p><h3 id="为什么要分块"><strong><span class="math inline">\(2.\)</span>为什么要分块？</strong></h3><p>说到区间操作，不难想到另外两个数据结构——树状数组与线段树。事实上，在很多问题中，这三个数据结构是可以通用的。区间求和就是一个经典例子。在这个问题中，树状数组与线段树的效率比分快都要高，为什么还有很多选择分块做法呢？原因是分块是最通用，最直观的。这样说也许十分抽象，接下来本文将以区间求和这一经典例题来引入分块思想。</p><h2 id="声明"><strong>声明：</strong></h2><p>不同OJ题目描述略有不同，但大多只是变量名的不同，无实质性区别。因此，请勿将同一份代码交到不同OJ。</p><h2 id="例一区间求和"><strong>【例一】区间求和</strong></h2><p><a href="https://www.luogu.com.cn/problem/P3372">题目链接</a><br />题目描述：给定一个长度为<span class="math inline">\(n\)</span> <span class="math inline">\((n\le 10^5)\)</span>的序列A,然后给定<span class="math inline">\(q\)</span> <span class="math inline">\((q\le 10^5)\)</span>个操作命令,操作命令如下:<br />命令一:形如“<span class="math inline">\(1\)</span> <span class="math inline">\(x\)</span> <span class="math inline">\(y\)</span> <span class="math inline">\(k\)</span>”，表示对于所有的正整数<span class="math inline">\(i(x\le i\le y)\)</span>，将<span class="math inline">\(A_i\)</span>加上一个<span class="math inline">\(k\)</span>。<br />命令二:形如"<span class="math inline">\(2\)</span> <span class="math inline">\(x\)</span> <span class="math inline">\(y\)</span>",表示求 <span class="math display">\[\sum_{i=x}^y{A_i}\]</span> <a href="https://www.luogu.com.cn/problem/P3372">对于不习惯用数学符号描述最简题面的读者可以点开原题题面</a></p><h2 id="solution"><strong><span class="math inline">\(Solution:\)</span></strong></h2><p>首先对数据规模进行分析，暴力肯定会超时。这可以用树状数组和线段树，但在这，我们用分块来做。<br />分块，首先就要确定“块”的长度，方便起见,我们记<span class="math inline">\(m\)</span>为块的长度。通常情况下，我们以<span class="math inline">\(\lfloor \sqrt{n}\rfloor\)</span>作为块的长度，即<span class="math inline">\(m=\lfloor \sqrt{n}\rfloor\)</span>。当然，大多数情况下，<span class="math inline">\(n\)</span>未必是一个完全平方数，也就是说，结尾部分会有不足。这时，我们只要单独处理就可以了。因此，我们可以将序列分成如下所示(方便起见，此处<span class="math inline">\(m\)</span>取<span class="math inline">\(2\)</span>)：</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/02fa725b2cf21669.png" /></p><p>首先，我们要确定每个块的位置。因此，我们定义<span class="math inline">\(l\)</span>数组与<span class="math inline">\(r\)</span>数组，作为每个块的左端点与右端点。不难得出，<span class="math inline">\(l_i=(i-1)×m+1,r_i=i×m\)</span>。如果有多余的部分，则令<span class="math inline">\(l_i=(i-1)×m+1,r_i=n\)</span>。<br /><span class="math inline">\(Code:\)</span></p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">int</span> num=n/m;<span class="co">//求出总块数</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=num;++i)&#123;</a><a class="sourceLine" id="cb1-3" title="3">    l[i]=(i-<span class="dv">1</span>)*m+<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-4" title="4">    r[i]=i*m;</a><a class="sourceLine" id="cb1-5" title="5">&#125;</a><a class="sourceLine" id="cb1-6" title="6"><span class="cf">if</span>(m*num&lt;n)&#123;<span class="co">//处理多余部分</span></a><a class="sourceLine" id="cb1-7" title="7">    ++num;</a><a class="sourceLine" id="cb1-8" title="8">    l[i]=(num-<span class="dv">1</span>)*m+<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-9" title="9">    r[i]=n;</a><a class="sourceLine" id="cb1-10" title="10">&#125;</a></code></pre></div><p>确定完每个块的边界后，我们还要判断<span class="math inline">\(A_i\)</span>的所属块。经过刚才对每个块左右端点的确定，这个操作变得十分容易。我们只需要用“块”将整个数列遍历一遍即可。具体实现方式如下:<br /><span class="math inline">\(Code:\)</span></p><div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=num;++i)&#123;</a><a class="sourceLine" id="cb2-2" title="2">    <span class="cf">for</span>(<span class="dt">int</span> j=l[i];j&lt;=r[i];++j)&#123;</a><a class="sourceLine" id="cb2-3" title="3">        p[j]=i;</a><a class="sourceLine" id="cb2-4" title="4">    &#125;</a><a class="sourceLine" id="cb2-5" title="5">&#125;</a></code></pre></div><p>到此为止，分块还并未发挥它的真正作用。而接下来的，便是分块思想中最重要的一环。<br />现在，我们要定义两个数组<span class="math inline">\(sum\)</span>与<span class="math inline">\(d\)</span>,分别表示每个块中数的和与每个块中的增量。首先要预处理出<span class="math inline">\(sum\)</span>，这只需在刚刚的<span class="math inline">\(for\)</span>循环中加一句<code>sum[i]+=a[j]</code>即可。在执行命令一时。对于一个完整的块，需要让<span class="math inline">\(sum_i\)</span>加上<span class="math inline">\(m*k\)</span>,并让<span class="math inline">\(d_i\)</span>加上<span class="math inline">\(k\)</span>。对于不完整的部分，则只要将<span class="math inline">\(sum_i\)</span>加上<span class="math inline">\(k\)</span>与该部分长度之积,并将原数列中对应的数加上<span class="math inline">\(k\)</span>。执行命令二时，同样的，分两种情况处理。我们记该区间和为<span class="math inline">\(ans\)</span>,对于不完整的部分，则暴力枚举。则让<span class="math inline">\(ans\)</span>加上<span class="math inline">\(A_i+d_{p_{A_i}}\)</span>,而对于一整个块，只需让<span class="math inline">\(ans\)</span>加上<span class="math inline">\(sum_i\)</span>即可。本来处理一个块的时间复杂度为<span class="math inline">\(O(m)\)</span>，如此一来，便降到了<span class="math inline">\(O(1)\)</span>。对于整个题目，暴力的时间复杂度为<span class="math inline">\(O(n^2)\)</span>,而分块则像是一种“优雅的暴力”，将遍历每个数变为遍历每个块，也就是将n降低为<span class="math inline">\(\sqrt{n}\)</span>,这就是分块的一个重要思想。该题分块时间复杂度理论上为<span class="math inline">\(O(n)\)</span>。真实复杂度还应加上预处理与对不完整部分的处理。即便如此，<span class="math inline">\(n=10^5\)</span>依然是能够支持的。</p><p><a href="https://www.luogu.com.cn/problem/P3372"><span class="math inline">\(Code:\)</span></a></p><div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></a><a class="sourceLine" id="cb3-2" title="2"><span class="pp">#define AK </span><span class="dv">1</span></a><a class="sourceLine" id="cb3-3" title="3"><span class="pp">#define int </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></a><a class="sourceLine" id="cb3-4" title="4"></a><a class="sourceLine" id="cb3-5" title="5"><span class="kw">namespace</span> FastIOstream&#123;</a><a class="sourceLine" id="cb3-6" title="6">    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">inline</span> <span class="dt">void</span> read(T &amp;x)&#123;<span class="co">//Fast read</span></a><a class="sourceLine" id="cb3-7" title="7">    x=<span class="dv">0</span>;<span class="dt">int</span> f=<span class="dv">1</span>;<span class="dt">char</span> c=getchar();<span class="cf">for</span>(;!isdigit(c);)&#123;</a><a class="sourceLine" id="cb3-8" title="8">            <span class="cf">if</span>(c==<span class="ch">&#39;-&#39;</span>)</a><a class="sourceLine" id="cb3-9" title="9">                f=-<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-10" title="10">            c=getchar();</a><a class="sourceLine" id="cb3-11" title="11">        &#125;</a><a class="sourceLine" id="cb3-12" title="12">        <span class="cf">for</span>(;isdigit(c);)&#123;</a><a class="sourceLine" id="cb3-13" title="13">            x=(x&lt;&lt;<span class="dv">1</span>)+(x&lt;&lt;<span class="dv">3</span>)+c-<span class="dv">48</span>;</a><a class="sourceLine" id="cb3-14" title="14">            c=getchar();</a><a class="sourceLine" id="cb3-15" title="15">        &#125;</a><a class="sourceLine" id="cb3-16" title="16">        x*=f;</a><a class="sourceLine" id="cb3-17" title="17">        <span class="cf">return</span>;</a><a class="sourceLine" id="cb3-18" title="18">    &#125;</a><a class="sourceLine" id="cb3-19" title="19">    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; </a><a class="sourceLine" id="cb3-20" title="20">    <span class="dt">void</span> print(T x)&#123;<span class="co">//Fast print</span></a><a class="sourceLine" id="cb3-21" title="21">        <span class="cf">if</span>(x&lt;<span class="dv">0</span>)&#123;</a><a class="sourceLine" id="cb3-22" title="22">            x=-x;</a><a class="sourceLine" id="cb3-23" title="23">            putchar(<span class="ch">&#39;-&#39;</span>);</a><a class="sourceLine" id="cb3-24" title="24">        &#125;</a><a class="sourceLine" id="cb3-25" title="25">        <span class="cf">if</span>(x&gt;<span class="dv">9</span>)&#123;</a><a class="sourceLine" id="cb3-26" title="26">            print((x&gt;&gt;<span class="dv">1</span>)/<span class="dv">5</span>);</a><a class="sourceLine" id="cb3-27" title="27">        &#125;</a><a class="sourceLine" id="cb3-28" title="28">        putchar(x%<span class="dv">10</span>+<span class="dv">48</span>);</a><a class="sourceLine" id="cb3-29" title="29">        <span class="cf">return</span>;</a><a class="sourceLine" id="cb3-30" title="30">    &#125;</a><a class="sourceLine" id="cb3-31" title="31">&#125;</a><a class="sourceLine" id="cb3-32" title="32"></a><a class="sourceLine" id="cb3-33" title="33"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb3-34" title="34"><span class="kw">using</span> <span class="kw">namespace</span> FastIOstream;</a><a class="sourceLine" id="cb3-35" title="35"></a><a class="sourceLine" id="cb3-36" title="36"><span class="dt">int</span> n,t,num,k,f[<span class="dv">100005</span>],l[<span class="dv">1005</span>],r[<span class="dv">1005</span>],p[<span class="dv">100005</span>],d[<span class="dv">1005</span>],sum[<span class="dv">1005</span>];</a><a class="sourceLine" id="cb3-37" title="37"></a><a class="sourceLine" id="cb3-38" title="38"><span class="dt">void</span> init()&#123;</a><a class="sourceLine" id="cb3-39" title="39">    read(n);</a><a class="sourceLine" id="cb3-40" title="40">    read(t);</a><a class="sourceLine" id="cb3-41" title="41">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;++i)&#123;</a><a class="sourceLine" id="cb3-42" title="42">        read(f[i]);</a><a class="sourceLine" id="cb3-43" title="43">    &#125;</a><a class="sourceLine" id="cb3-44" title="44">    k=sqrt(n);</a><a class="sourceLine" id="cb3-45" title="45">    num=n/k;</a><a class="sourceLine" id="cb3-46" title="46">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=num;++i)&#123;</a><a class="sourceLine" id="cb3-47" title="47">        l[i]=(i-<span class="dv">1</span>)*k+<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-48" title="48">        r[i]=i*k;</a><a class="sourceLine" id="cb3-49" title="49">    &#125;</a><a class="sourceLine" id="cb3-50" title="50">    <span class="cf">if</span>(k*num&lt;n)&#123;</a><a class="sourceLine" id="cb3-51" title="51">        num++;</a><a class="sourceLine" id="cb3-52" title="52">        l[num]=(num-<span class="dv">1</span>)*k+<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-53" title="53">        r[num]=n;</a><a class="sourceLine" id="cb3-54" title="54">    &#125;</a><a class="sourceLine" id="cb3-55" title="55">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=num;++i)&#123;</a><a class="sourceLine" id="cb3-56" title="56">        <span class="cf">for</span>(<span class="dt">int</span> j=l[i];j&lt;=r[i];++j)&#123;</a><a class="sourceLine" id="cb3-57" title="57">            p[j]=i;</a><a class="sourceLine" id="cb3-58" title="58">            sum[i]+=f[j];</a><a class="sourceLine" id="cb3-59" title="59">        &#125;</a><a class="sourceLine" id="cb3-60" title="60">    &#125;</a><a class="sourceLine" id="cb3-61" title="61">    <span class="cf">return</span>;</a><a class="sourceLine" id="cb3-62" title="62">&#125;</a><a class="sourceLine" id="cb3-63" title="63"></a><a class="sourceLine" id="cb3-64" title="64"><span class="dt">void</span> change(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> w)&#123;</a><a class="sourceLine" id="cb3-65" title="65">    <span class="cf">if</span>(p[x]==p[y])&#123;</a><a class="sourceLine" id="cb3-66" title="66">        <span class="cf">for</span>(<span class="dt">int</span> i=x;i&lt;=y;++i)&#123;</a><a class="sourceLine" id="cb3-67" title="67">            f[i]+=w;</a><a class="sourceLine" id="cb3-68" title="68">            sum[p[x]]+=w;</a><a class="sourceLine" id="cb3-69" title="69">        &#125;</a><a class="sourceLine" id="cb3-70" title="70">    &#125;</a><a class="sourceLine" id="cb3-71" title="71">    <span class="cf">else</span>&#123;</a><a class="sourceLine" id="cb3-72" title="72">        <span class="dt">int</span> ql=p[x]+<span class="dv">1</span>,qr=p[y]-<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-73" title="73">        <span class="cf">for</span>(<span class="dt">int</span> i=ql;i&lt;=qr;++i)&#123;</a><a class="sourceLine" id="cb3-74" title="74">            sum[i]+=w*k;</a><a class="sourceLine" id="cb3-75" title="75">            d[i]+=w;</a><a class="sourceLine" id="cb3-76" title="76">        &#125;</a><a class="sourceLine" id="cb3-77" title="77">        <span class="cf">for</span>(<span class="dt">int</span> i=x;i&lt;=r[p[x]];++i)&#123;</a><a class="sourceLine" id="cb3-78" title="78">            sum[p[x]]+=w;</a><a class="sourceLine" id="cb3-79" title="79">            f[i]+=w;</a><a class="sourceLine" id="cb3-80" title="80">        &#125;</a><a class="sourceLine" id="cb3-81" title="81">        <span class="cf">for</span>(<span class="dt">int</span> j=l[p[y]];j&lt;=y;++j)&#123;</a><a class="sourceLine" id="cb3-82" title="82">            sum[p[y]]+=w;</a><a class="sourceLine" id="cb3-83" title="83">            f[j]+=w;</a><a class="sourceLine" id="cb3-84" title="84">        &#125;</a><a class="sourceLine" id="cb3-85" title="85">    &#125;</a><a class="sourceLine" id="cb3-86" title="86">    <span class="cf">return</span>;</a><a class="sourceLine" id="cb3-87" title="87">&#125;</a><a class="sourceLine" id="cb3-88" title="88"></a><a class="sourceLine" id="cb3-89" title="89"><span class="dt">int</span> ask(<span class="dt">int</span> x,<span class="dt">int</span> y)&#123;</a><a class="sourceLine" id="cb3-90" title="90">    <span class="dt">int</span> ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb3-91" title="91">    <span class="cf">if</span>(p[x]==p[y])&#123;</a><a class="sourceLine" id="cb3-92" title="92">        <span class="cf">for</span>(<span class="dt">int</span> i=x;i&lt;=y;++i)&#123;</a><a class="sourceLine" id="cb3-93" title="93">            ans+=f[i]+d[p[x]];</a><a class="sourceLine" id="cb3-94" title="94">        &#125;</a><a class="sourceLine" id="cb3-95" title="95">    &#125;</a><a class="sourceLine" id="cb3-96" title="96">    <span class="cf">else</span>&#123;</a><a class="sourceLine" id="cb3-97" title="97">        <span class="dt">int</span> ql=p[x]+<span class="dv">1</span>,qr=p[y]-<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-98" title="98">        <span class="cf">for</span>(<span class="dt">int</span> i=ql;i&lt;=qr;++i)&#123;</a><a class="sourceLine" id="cb3-99" title="99">            ans+=sum[i];</a><a class="sourceLine" id="cb3-100" title="100">        &#125;</a><a class="sourceLine" id="cb3-101" title="101">        <span class="cf">for</span>(<span class="dt">int</span> i=x;i&lt;=r[p[x]];++i)&#123;</a><a class="sourceLine" id="cb3-102" title="102">            ans+=f[i]+d[p[x]];</a><a class="sourceLine" id="cb3-103" title="103">        &#125;</a><a class="sourceLine" id="cb3-104" title="104">        <span class="cf">for</span>(<span class="dt">int</span> j=l[p[y]];j&lt;=y;++j)&#123;</a><a class="sourceLine" id="cb3-105" title="105">             ans+=f[j]+d[p[y]];</a><a class="sourceLine" id="cb3-106" title="106">        &#125;</a><a class="sourceLine" id="cb3-107" title="107">    &#125;</a><a class="sourceLine" id="cb3-108" title="108">    <span class="cf">return</span> ans;</a><a class="sourceLine" id="cb3-109" title="109">&#125;</a><a class="sourceLine" id="cb3-110" title="110"></a><a class="sourceLine" id="cb3-111" title="111"><span class="dt">signed</span> main()&#123;</a><a class="sourceLine" id="cb3-112" title="112">    init();</a><a class="sourceLine" id="cb3-113" title="113">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=t;++i)&#123;</a><a class="sourceLine" id="cb3-114" title="114">        <span class="dt">int</span> op,x,y,w;</a><a class="sourceLine" id="cb3-115" title="115">        read(op);</a><a class="sourceLine" id="cb3-116" title="116">        read(x);</a><a class="sourceLine" id="cb3-117" title="117">        read(y);</a><a class="sourceLine" id="cb3-118" title="118">        <span class="cf">if</span>(op==<span class="dv">1</span>)&#123;</a><a class="sourceLine" id="cb3-119" title="119">            read(w);</a><a class="sourceLine" id="cb3-120" title="120">            change(x,y,w);</a><a class="sourceLine" id="cb3-121" title="121">        &#125;</a><a class="sourceLine" id="cb3-122" title="122">        <span class="cf">else</span>&#123;</a><a class="sourceLine" id="cb3-123" title="123">            print(ask(x,y));</a><a class="sourceLine" id="cb3-124" title="124">            puts(<span class="st">&quot; &quot;</span>);</a><a class="sourceLine" id="cb3-125" title="125">        &#125;</a><a class="sourceLine" id="cb3-126" title="126">    &#125;</a><a class="sourceLine" id="cb3-127" title="127">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-128" title="128">&#125;</a></code></pre></div><p><span class="math inline">\(Markdown\)</span> <span class="math inline">\(with\)</span> <span class="math inline">\(\LaTeX\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
